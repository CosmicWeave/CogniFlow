import { useCallback } from 'react';
import { AIGenerationParams, DeckType, LearningDeck, QuizDeck, AIAction, AIActionType, InfoCard, Question, SeriesLevel, DeckSeries } from '../../types';
import * as aiService from '../../services/aiService';
import { createQuestionsFromImport } from '../../services/importService';
import { useStore } from '../../store/store';

// This is not a hook, but a factory function that creates a set of related handlers.
export const createAIHandlers = ({ dispatch, addToast, handleAddSeriesWithDecks, handleAddDecks, handleUpdateDeck, handleUpdateSeries, handleMoveDeck, handleDeleteDeck, handleSaveFolder, handleDeleteFolder }: any) => {

  const handleGenerateWithAI = useCallback(async (params: AIGenerationParams & { generationType: 'series' | 'deck' | 'learning', generateQuestions?: boolean, isLearningMode?: boolean }) => {
    const { generationType, generateQuestions, isLearningMode, ...aiParams } = params;
    
    const initialTask: any = {
      id: crypto.randomUUID(),
      payload: params,
      statusText: `Initializing AI generation for '${params.topic}'...`
    };

    if (generationType === 'series') {
        initialTask.type = isLearningMode ? 'generateSeriesLearningContentInBatches' : (generateQuestions ? 'generateSeriesQuestionsInBatches' : 'generateSeriesScaffoldWithAI');
    } else {
        initialTask.type = isLearningMode ? 'generateLearningDeckWithAI' : 'generateDeckWithAI';
    }

    dispatch({ type: 'ADD_AI_TASK_TO_QUEUE', payload: initialTask });
    addToast("AI task has been added to the queue.", "info");

  }, [dispatch, addToast]);

  const handleGenerateQuestionsForDeck = useCallback(async (deck: QuizDeck) => {
    const task = {
      id: crypto.randomUUID(),
      type: 'generateQuestionsForDeck',
      payload: { 
        deckId: deck.id, 
        count: deck.suggestedQuestionCount || 15 
      },
      statusText: `Queueing question generation for "${deck.name}"...`,
      deckId: deck.id,
    };
    dispatch({ type: 'ADD_AI_TASK_TO_QUEUE', payload: task });
    addToast(`Task to generate questions for "${deck.name}" has been queued.`, 'info');
  }, [dispatch, addToast]);

  const handleGenerateContentForLearningDeck = useCallback(async (deck: LearningDeck) => {
    const task = {
      id: crypto.randomUUID(),
      type: 'generateLearningDeckWithAI',
      payload: { deckId: deck.id },
      statusText: `Queueing content generation for "${deck.name}"...`,
      deckId: deck.id
    };
     dispatch({ type: 'ADD_AI_TASK_TO_QUEUE', payload: task });
    addToast(`Task to generate content for "${deck.name}" has been queued.`, 'info');
  }, [addToast, dispatch]);

  const handleAiAddLevelsToSeries = useCallback(async (seriesId: string) => {
    const task = {
        id: crypto.randomUUID(),
        type: 'generateMoreLevelsForSeries',
        payload: { seriesId },
        statusText: `Queueing task to expand series...`,
        seriesId: seriesId,
    };
    dispatch({ type: 'ADD_AI_TASK_TO_QUEUE', payload: task });
    addToast("Task to expand series has been queued.", "info");
  }, [dispatch, addToast]);

  const handleAiAddDecksToLevel = useCallback(async (seriesId: string, levelIndex: number) => {
     const task = {
        id: crypto.randomUUID(),
        type: 'generateMoreDecksForLevel',
        payload: { seriesId, levelIndex },
        statusText: `Queueing task to add decks to level ${levelIndex + 1}...`,
        seriesId: seriesId,
    };
    dispatch({ type: 'ADD_AI_TASK_TO_QUEUE', payload: task });
    addToast("Task to add more decks has been queued.", "info");
  }, [dispatch, addToast]);

  const handleExecuteAIAction = useCallback(async (action: AIAction) => {
    const { decks, folders, deckSeries } = useStore.getState();
    const { payload } = action;

    switch (action.action) {
        case AIActionType.CREATE_DECK:
            if (payload.name) handleAddDecks([{ id: crypto.randomUUID(), name: payload.name, type: DeckType.Quiz, questions: [], description: 'Generated by AI Assistant' }]);
            break;
        case AIActionType.RENAME_DECK:
            if (payload.deckId && payload.newName) {
                const deck = decks.find(d => d.id === payload.deckId);
                if (deck) handleUpdateDeck({ ...deck, name: payload.newName });
            }
            break;
        case AIActionType.MOVE_DECK_TO_FOLDER:
            if (payload.deckId) handleMoveDeck(payload.deckId, payload.folderId);
            break;
        case AIActionType.DELETE_DECK:
            if (payload.deckId) handleDeleteDeck(payload.deckId);
            break;
        case AIActionType.CREATE_FOLDER:
            if (payload.name) handleSaveFolder({ id: null, name: payload.name });
            break;
        case AIActionType.RENAME_FOLDER:
            if (payload.folderId && payload.newName) handleSaveFolder({ id: payload.folderId, name: payload.newName });
            break;
        case AIActionType.DELETE_FOLDER:
            if (payload.folderId) handleDeleteFolder(payload.folderId);
            break;
        case AIActionType.EXPAND_SERIES_ADD_LEVELS:
            if (payload.seriesId) handleAiAddLevelsToSeries(payload.seriesId);
            break;
        case AIActionType.EXPAND_SERIES_ADD_DECKS:
            if (payload.seriesId && typeof payload.levelIndex === 'number') handleAiAddDecksToLevel(payload.seriesId, payload.levelIndex);
            break;
        case AIActionType.GENERATE_QUESTIONS_FOR_DECK:
            if (payload.deckId) {
                const deck = decks.find(d => d.id === payload.deckId);
                if (deck && (deck.type === DeckType.Quiz || deck.type === DeckType.Learning)) handleGenerateQuestionsForDeck(deck as QuizDeck);
            }
            break;
        case AIActionType.NO_ACTION:
            // No operation, the message is purely conversational.
            break;
        default:
            addToast(`Action "${action.action}" is not implemented.`, 'error');
    }
  }, [addToast, handleAddDecks, handleDeleteDeck, handleDeleteFolder, handleMoveDeck, handleSaveFolder, handleUpdateDeck, handleAiAddDecksToLevel, handleAiAddLevelsToSeries, handleGenerateQuestionsForDeck]);

  const handleGenerateQuestionsForEmptyDecksInSeries = useCallback(async (seriesId: string) => {
    const { decks, deckSeries, aiGenerationStatus } = useStore.getState();
    const series = deckSeries.find(s => s.id === seriesId);
    if (!series) {
        addToast("Series not found.", "error");
        return;
    }
    const emptyDecks = series.levels
        .flatMap(l => l.deckIds)
        .map(id => decks.find(d => d.id === id))
        .filter((d): d is (QuizDeck | LearningDeck) => !!d && (d.type === DeckType.Quiz || d.type === DeckType.Learning) && d.questions.length === 0);

    if (emptyDecks.length === 0) {
        addToast("No empty decks to generate questions for.", "info");
        return;
    }
    
    if (aiGenerationStatus.currentTask || aiGenerationStatus.queue.length > 0) {
        addToast("An AI task is already running. Please wait.", "info");
        return;
    }

    const tasks: any[] = emptyDecks.map(deck => ({
      id: crypto.randomUUID(),
      type: deck.type === DeckType.Learning ? 'generateLearningDeckWithAI' : 'generateQuestionsForDeck',
      payload: { 
          deckId: deck.id, 
          count: deck.suggestedQuestionCount || 15 
      },
      statusText: `Queueing task for "${deck.name}"...`,
      deckId: deck.id,
      seriesId: seriesId,
    }));
    
    tasks.forEach(task => dispatch({ type: 'ADD_AI_TASK_TO_QUEUE', payload: task }));
    addToast(`Queued ${tasks.length} AI generation tasks for "${series.name}".`, "info");
  }, [addToast, dispatch]);
  
  const handleCancelAIGeneration = useCallback((taskId?: string) => {
    dispatch({ type: 'CANCEL_AI_TASK', payload: { taskId } });
    addToast("AI generation task cancelled.", "info");
  }, [dispatch, addToast]);
  
  const handleSaveLearningBlock = useCallback(async (deckId: string, blockData: { infoCard: InfoCard; questions: Question[] }) => {
    const deck = useStore.getState().decks.find(d => d.id === deckId);
    if (!deck || deck.type !== DeckType.Learning) return;
    
    const { infoCard, questions } = blockData;
    const isEditing = deck.infoCards.some(ic => ic.id === infoCard.id);
    
    let updatedInfoCards: InfoCard[];
    let updatedQuestions: Question[];

    if (isEditing) {
        updatedInfoCards = deck.infoCards.map(ic => ic.id === infoCard.id ? infoCard : ic);
        const otherQuestions = deck.questions.filter(q => !infoCard.unlocksQuestionIds.includes(q.id));
        updatedQuestions = [...otherQuestions, ...questions];
    } else {
        updatedInfoCards = [...deck.infoCards, infoCard];
        updatedQuestions = [...deck.questions, ...questions];
    }
    
    await handleUpdateDeck({ ...deck, infoCards: updatedInfoCards, questions: updatedQuestions });
    addToast(`Learning block ${isEditing ? 'updated' : 'added'}.`, 'success');
  }, [handleUpdateDeck, addToast]);

  const handleDeleteLearningBlock = useCallback(async (deckId: string, infoCardId: string) => {
    const deck = useStore.getState().decks.find(d => d.id === deckId);
    if (!deck || deck.type !== DeckType.Learning) return;

    const infoCardToDelete = deck.infoCards.find(ic => ic.id === infoCardId);
    if (!infoCardToDelete) return;
    
    const questionIdsToDelete = new Set(infoCardToDelete.unlocksQuestionIds);

    const updatedInfoCards = deck.infoCards.filter(ic => ic.id !== infoCardId);
    const updatedQuestions = deck.questions.filter(q => !questionIdsToDelete.has(q.id));
    
    await handleUpdateDeck({ ...deck, infoCards: updatedInfoCards, questions: updatedQuestions });
    addToast("Learning block deleted.", "success");
  }, [handleUpdateDeck, addToast]);

  return {
    handleGenerateWithAI,
    handleGenerateQuestionsForDeck,
    handleGenerateContentForLearningDeck,
    handleAiAddLevelsToSeries,
    handleAiAddDecksToLevel,
    handleExecuteAIAction,
    handleGenerateQuestionsForEmptyDecksInSeries,
    handleCancelAIGeneration,
    handleSaveLearningBlock,
    handleDeleteLearningBlock,
  };
};